<body>
	<canvas id="waveCanvas" width="800" height="150">
	</canvas>	
</body>

<script>
	var audioCtx = new (window.AudioContext || window.webkitAudioContext)();
	var waveform;

	var dropZone = document.body;
	dropZone.ondragover = function (e) {
		e.stopPropagation();
		e.preventDefault();
		
		e.dataTransfer.dropEffect = 'copy';
	};

	dropZone.ondragenter = function (e) {
		document.body.style.backgroundColor='#dfd';
	};

	dropZone.ondragleave = function (e) {
		document.body.style.backgroundColor='white';
	};

	dropZone.ondrop = function (e) {
		e.stopPropagation();
		e.preventDefault();

		document.body.style.backgroundColor='white';

		var files = e.dataTransfer.files;
		if (files.length > 0) {
			var file = files[0];
			
			if (!(file.type.length > 6 && file.type.substring(0, 6) === 'audio/')) {
				return;
			}

			var reader = new FileReader();
			reader.onload = function (e) {
				audioCtx.decodeAudioData(e.target.result).then(function (audioBuffer) {
					var editor = new MarkerEditor(document.getElementById('waveCanvas'), audioBuffer);

					document.onkeydown = e => {
						if (e.keyCode === 32) {
							if (editor.playing) {
								editor.stop();
							} else {
								editor.play();
							}
						}
					};
				});
			};

			reader.readAsArrayBuffer(file);
		}
	};

	class MarkerEditor {
		constructor (canvas, audioBuffer) {
			this.waveform = new Waveform(audioBuffer, 1000);

			this.canvas = canvas;
			this.audioBuffer = audioBuffer;

			this.totalOffset = 0;
			this.startOffset = this.totalOffset;
			this.zoomLevel = canvas.width / this.waveform.length;	// pixels per second
			this.mouseStart = 0;
			this.dragging = false;
			this.cursor = 0;
			this.playing = false;

			this.canvas.focus();

			this.canvas.onwheel = e => {
				this.dragging = false;

				if (e.deltaY < 0) {		// scroll up
					this.zoom(1.1);
				} else {
					this.zoom(0.9);
				}
			};
			this.canvas.onmousedown = e => {
				this.dragging = true;
				this.mouseStart = e.clientX;
				this.startOffset = this.totalOffset;
			};
			window.onmousemove = e => {
				this.mouseX = e.clientX - this.canvas.getBoundingClientRect().left;

				if (this.dragging) {
					var mouseNow = e.clientX;
					this.totalOffset = this.startOffset + (this.mouseStart - mouseNow) / this.zoomLevel;
					this.clipOffset();
				}
			};
			window.onmouseup = e => {
				this.dragging = false;
				if (e.clientX === this.mouseStart) {	// the mouse was clicked, not dragged
					this.cursor = this.totalOffset + this.mouseX / this.zoomLevel;
				}
			};
			window.requestAnimationFrame(this.canvasRender.bind(this));
		}

		zoom (multiplier) {
			var focus = this.cursor;	// centre zoom on playing cursor

			var zoomLevelMultiplier = multiplier;
			var zoomLevelOriginal = this.zoomLevel;

			this.zoomLevel *= zoomLevelMultiplier;

			if (this.zoomLevel > this.waveform.maxResolution) {
				this.zoomLevel = this.waveform.maxResolution;
			}
			if (this.zoomLevel < this.canvas.width / this.waveform.length) {
				this.zoomLevel = this.canvas.width / this.waveform.length;
			}

			zoomLevelMultiplier = this.zoomLevel / zoomLevelOriginal;	// adjust in case the zoom level was clipped
			this.totalOffset = (this.totalOffset - focus) / zoomLevelMultiplier + focus;	// move the offset so we zoom centred on the cursor

			this.clipOffset();
		}

		canvasRender () {
			if (this.playing) {
				this.cursor = audioCtx.currentTime - this.startTime + this.startTimecode;
				this.centreCursor();
			}
			this.canvas.getContext('2d').fillStyle = 'black';
			this.waveform.drawWaveform(this.canvas, this.totalOffset, this.canvas.width / this.zoomLevel);
			var cursorX = (this.cursor - this.totalOffset) * this.zoomLevel;
			this.canvas.getContext('2d').fillStyle = 'green';
			this.canvas.getContext('2d').fillRect(cursorX, 0, 1, this.canvas.height);

			window.requestAnimationFrame(this.canvasRender.bind(this));
		};

		clipOffset () {
			if (this.totalOffset < 0)
				this.totalOffset = 0;
			if (this.canvas.width > (this.waveform.length - this.totalOffset) * this.zoomLevel)
				this.totalOffset = this.waveform.length - this.canvas.width / this.zoomLevel;
		};

		centreCursor () {
			var secondsOnScreen = this.canvas.width / this.zoomLevel;
			this.totalOffset = this.cursor - secondsOnScreen / 2;
			this.clipOffset();
		};

		play () {
			if (this.playing)
				return;

			this.playing = true;

			this.source = audioCtx.createBufferSource();
			this.source.buffer = this.audioBuffer;
			this.source.connect(audioCtx.destination);
			this.source.start(0, this.cursor);

			this.startTime = audioCtx.currentTime;
			this.startTimecode = this.cursor;
		}

		stop () {
			if (!this.playing)
				return;

			this.playing = false;

			this.source.stop();
		}
	}

	class Waveform {
		constructor (arrayBuffer, maxResolution) {
			this.buffer = arrayBuffer;
			this.maxResolution = maxResolution;
			this.summarize(maxResolution);
			
			console.log('waveform constructed');
		}

		summarize (pixelsPerSecond) {
			var data = this.data;
			var scaleFactor = Math.floor(data[0].length / (pixelsPerSecond * this.length));

			this.summaryMins = new Float32Array(Math.ceil(data[0].length / scaleFactor));
			this.summaryMaxes = new Float32Array(Math.ceil(data[0].length / scaleFactor));

			for (var i = 0; i < this.summaryMins.length; i++) {
				var currentMin = 1;
				var currentMax = -1;

				for (var j = 0; j < scaleFactor; j++) {
					var n = i * scaleFactor + j;
					if (n < data[0].length) {
						var sample = (data[0][n] + data[1][n]) / 2;
						if (sample < currentMin)
							currentMin = sample;
						if (sample > currentMax)
							currentMax = sample;
					} else {
						break;
					}
				}

				this.summaryMins[i] = currentMin;
				this.summaryMaxes[i] = currentMax;
			}
		}

		summarizeFurther (pixels, startTime, length) {
			if (!this.summaryMins || !this.summaryMaxes)
				return;

			var newMins = new Float32Array(pixels);
			var newMaxes = new Float32Array(pixels);

			var summaryOffset = Math.floor(startTime * this.maxResolution);
			var lengthFrames = Math.floor(length * this.maxResolution);

			if (lengthFrames < pixels) {	// The old summary's length over this time region is smaller; we're expanding
				var currentPixel = 0;
				for (var i = 0; i < lengthFrames; i++) {
					while (currentPixel / pixels < (i + 1) / lengthFrames) {	// we use i + 1 so it takes a whole batch from the start
						newMins[currentPixel] = this.summaryMins[summaryOffset + i];
						newMaxes[currentPixel] = this.summaryMaxes[summaryOffset + i];
						currentPixel++;
					}
				}
			} else {	// We're condensing old summary data down into a smaller space (this should happen more often)
				var framesPerVirtualPixel = lengthFrames / pixels;
				var totalSummaryFrames = this.length * this.maxResolution;
				var virtualPixelsPerFrame = 1 / framesPerVirtualPixel;
				var totalVirtualPixels = totalSummaryFrames * virtualPixelsPerFrame;
				var initialVirtualPixel = Math.floor(startTime / this.length * totalVirtualPixels);

				var i = 0;
				for (var virtualPixel = initialVirtualPixel; virtualPixel < initialVirtualPixel + pixels; virtualPixel++) {

					// at certain bitrates there is occasionally a problem with vertical lines showing up at close zooms.
					// this is because there's not always a frame available to a virtual pixel.
					// in these cases, we copy the previous pixel.
					if (Math.floor(virtualPixel / totalVirtualPixels * totalSummaryFrames) !== Math.floor((virtualPixel + 1) / totalVirtualPixels * totalSummaryFrames)) {
						var currentMin = 1;
						var currentMax = -1;

						for (var frame = Math.floor(virtualPixel / totalVirtualPixels * totalSummaryFrames); frame < Math.floor((virtualPixel + 1) / totalVirtualPixels * totalSummaryFrames); frame++) {
							if (this.summaryMins[frame] < currentMin)
								currentMin = this.summaryMins[frame];
							if (this.summaryMaxes[frame] > currentMax)
								currentMax = this.summaryMaxes[frame];
						}

						newMins[i] = currentMin;
						newMaxes[i] = currentMax;
					} else if (i !== 0) {
						newMins[i] = newMins[i - 1];
						newMaxes[i] = newMaxes[i - 1];
					} else {
						newMins[i] = 0;
						newMaxes[i] = 0;
					}

					i++;
				}
			}

			return [newMins, newMaxes];
		}

		get data() {
			if (this.buffer.numberOfChannels === 1) {
				return [this.buffer.getChannelData(0), this.buffer.getChannelData(0)];
			} else {
				return [this.buffer.getChannelData(0), this.buffer.getChannelData(1)];
			}
		}

		get length() {
			return this.buffer.length / this.buffer.sampleRate;
		}

		getImage(width, height, startTime, length) {
			var canvas = document.createElement('canvas');
			canvas.width = width;
			canvas.height = height;
			canvas.getContext('2d').fillStyle = 'black';
			this.drawWaveform(canvas, startTime, length);
			return canvas.toDataURL();
		}

		drawWaveform(canvas, startTime, length) {
			var context = canvas.getContext('2d');
			context.clearRect(0, 0, canvas.width, canvas.height);

			if (startTime === undefined) {
				startTime = 0;
			}

			if (length === undefined) {
				length = this.length;
			}

			var pixels = this.summarizeFurther(canvas.width, startTime, length);
			var _startTime = +new Date();
			for (var i = 0; i < canvas.width; i++) {
				context.fillRect(i, -pixels[1][i] * canvas.height / 2 + canvas.height / 2, 1, (pixels[1][i] - pixels[0][i]) * canvas.height / 2);
			}
		}
	}

	/*
		test:
		with maxResolution = 1000
		summarizeFurther(100, 1, 0.1) -> ret
			ret[0] === waveform.summaryMins.slice(1000, 1100)
			ret[1] === waveform.summaryMaxes.slice(1000, 1100)
	*/
</script>
