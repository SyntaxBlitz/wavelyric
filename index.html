<body>
	<canvas id="waveCanvas" width="800" height="150">
	</canvas>	
</body>

<script>
	var audioCtx = new (window.AudioContext || window.webkitAudioContext)();
	var waveform;

	var dropZone = document.body;
	dropZone.ondragover = function (e) {
		e.stopPropagation();
		e.preventDefault();
		
		e.dataTransfer.dropEffect = 'copy';
	};

	dropZone.ondragenter = function (e) {
		document.body.style.backgroundColor='#dfd';
	};

	dropZone.ondragleave = function (e) {
		document.body.style.backgroundColor='white';
	};

	dropZone.ondrop = function (e) {
		e.stopPropagation();
		e.preventDefault();

		document.body.style.backgroundColor='white';

		var files = e.dataTransfer.files;
		if (files.length > 0) {
			var file = files[0];
			
			if (!(file.type.length > 6 && file.type.substring(0, 6) === 'audio/')) {
				return;
			}

			var reader = new FileReader();
			reader.onload = function (e) {
				var source;
				audioCtx.decodeAudioData(e.target.result).then(function (audioBuffer) {
					waveform = new Waveform(audioBuffer, 1000);

					var startTime;
					var startTimecode;

					var cv = document.getElementById('waveCanvas');
					cv.focus();
					var totalOffset = 0;
					var startOffset = totalOffset;
					var zoomLevel = cv.width / waveform.length;	// pixels per second
					var mouseStart = 0;
					var dragging = false;
					cursor = 0;
					var playing = false;

					var canvasRender = function () {
						if (playing) {
							cursor = audioCtx.currentTime - startTime + startTimecode;
							centreCursor();
						}
						cv.getContext('2d').fillStyle = 'black';
						waveform.drawWaveform(cv, totalOffset, cv.width / zoomLevel);
						cursorX = (cursor - totalOffset) * zoomLevel;
						cv.getContext('2d').fillStyle = 'green';
						cv.getContext('2d').fillRect(cursorX, 0, 1, cv.height);

						window.requestAnimationFrame(canvasRender);
					};

					var clipOffset = function () {
						if (totalOffset < 0)
							totalOffset = 0;
						if (cv.width > (waveform.length - totalOffset) * zoomLevel)
							totalOffset = waveform.length - cv.width / zoomLevel;
					};

					var centreCursor = function () {
						var secondsOnScreen = cv.width / zoomLevel;
						totalOffset = cursor - secondsOnScreen / 2;
						clipOffset();
					};

					cv.onwheel = function (e) {
						dragging = false;

						var focus = cursor;	// centre zoom on playing cursor

						var zoomLevelMultiplier = (-e.deltaY / 500 + 1);
						var zoomLevelOriginal = zoomLevel;
						zoomLevel *= zoomLevelMultiplier;

						if (zoomLevel > waveform.maxResolution) {
							zoomLevel = waveform.maxResolution;
						}
						if (zoomLevel < cv.width / waveform.length) {
							zoomLevel = cv.width / waveform.length;
						}

						zoomLevelMultiplier = zoomLevel / zoomLevelOriginal;	// adjust in case the zoom level was clipped
						totalOffset = (totalOffset - focus) / zoomLevelMultiplier + focus;	// move the offset so we zoom centred on the cursor

						clipOffset();
					};
					cv.onmousedown = function (e) {
						dragging = true;
						mouseStart = e.clientX;
						startOffset = totalOffset;
					};
					window.onmousemove = function (e) {
						mouseX = e.clientX - cv.getBoundingClientRect().left;

						if (dragging) {
							var mouseNow = e.clientX;
							totalOffset = startOffset + (mouseStart - mouseNow) / zoomLevel;
							clipOffset();
						}
					};
					window.onmouseup = function (e) {
						dragging = false;
						if (e.clientX === mouseStart) {	// the mouse was clicked, not dragged
							cursor = totalOffset + mouseX / zoomLevel;
						}
					};

					document.onkeydown = function (e) {
						if (e.keyCode === 32) {
							playing = !playing;

							if (playing) {
								source = audioCtx.createBufferSource();
								source.buffer = audioBuffer;
								source.connect(audioCtx.destination);
								source.start(0, cursor);

								startTime = audioCtx.currentTime;
								startTimecode = cursor;
							} else {
								source.stop();
							}
						}
					};
					window.requestAnimationFrame(canvasRender);
				});
			};

			reader.readAsArrayBuffer(file);
		}
	};

	class Waveform {
		constructor (arrayBuffer, maxResolution) {
			this.buffer = arrayBuffer;
			this.maxResolution = maxResolution;
			this.summarize(maxResolution);
			
			console.log('waveform constructed');
		}

		summarize (pixelsPerSecond) {
			var data = this.data;
			var scaleFactor = Math.floor(data[0].length / (pixelsPerSecond * this.length));

			this.summaryMins = new Float32Array(Math.ceil(data[0].length / scaleFactor));
			this.summaryMaxes = new Float32Array(Math.ceil(data[0].length / scaleFactor));

			for (var i = 0; i < this.summaryMins.length; i++) {
				var currentMin = 1;
				var currentMax = -1;

				for (var j = 0; j < scaleFactor; j++) {
					var n = i * scaleFactor + j;
					if (n < data[0].length) {
						var sample = (data[0][n] + data[1][n]) / 2;
						if (sample < currentMin)
							currentMin = sample;
						if (sample > currentMax)
							currentMax = sample;
					} else {
						break;
					}
				}

				this.summaryMins[i] = currentMin;
				this.summaryMaxes[i] = currentMax;
			}
		}

		summarizeFurther (pixels, startTime, length) {
			if (!this.summaryMins || !this.summaryMaxes)
				return;

			var newMins = new Float32Array(pixels);
			var newMaxes = new Float32Array(pixels);

			var summaryOffset = Math.floor(startTime * this.maxResolution);
			var lengthFrames = Math.floor(length * this.maxResolution);

			if (lengthFrames < pixels) {	// The old summary's length over this time region is smaller; we're expanding
				var currentPixel = 0;
				for (var i = 0; i < lengthFrames; i++) {
					while (currentPixel / pixels < (i + 1) / lengthFrames) {	// we use i + 1 so it takes a whole batch from the start
						newMins[currentPixel] = this.summaryMins[summaryOffset + i];
						newMaxes[currentPixel] = this.summaryMaxes[summaryOffset + i];
						currentPixel++;
					}
				}
			} else {	// We're condensing old summary data down into a smaller space (this should happen more often)
				var framesPerVirtualPixel = lengthFrames / pixels;
				var totalSummaryFrames = this.length * this.maxResolution;
				var virtualPixelsPerFrame = 1 / framesPerVirtualPixel;
				var totalVirtualPixels = totalSummaryFrames * virtualPixelsPerFrame;
				var initialVirtualPixel = Math.floor(startTime / this.length * totalVirtualPixels);

				var i = 0;
				for (var virtualPixel = initialVirtualPixel; virtualPixel < initialVirtualPixel + pixels; virtualPixel++) {

					// at certain bitrates there is occasionally a problem with vertical lines showing up at close zooms.
					// this is because there's not always a frame available to a virtual pixel.
					// in these cases, we copy the previous pixel.
					if (Math.floor(virtualPixel / totalVirtualPixels * totalSummaryFrames) !== Math.floor((virtualPixel + 1) / totalVirtualPixels * totalSummaryFrames)) {
						var currentMin = 1;
						var currentMax = -1;

						for (var frame = Math.floor(virtualPixel / totalVirtualPixels * totalSummaryFrames); frame < Math.floor((virtualPixel + 1) / totalVirtualPixels * totalSummaryFrames); frame++) {
							if (this.summaryMins[frame] < currentMin)
								currentMin = this.summaryMins[frame];
							if (this.summaryMaxes[frame] > currentMax)
								currentMax = this.summaryMaxes[frame];
						}

						newMins[i] = currentMin;
						newMaxes[i] = currentMax;
					} else if (i !== 0) {
						newMins[i] = newMins[i - 1];
						newMaxes[i] = newMaxes[i - 1];
					} else {
						newMins[i] = 0;
						newMaxes[i] = 0;
					}

					i++;
				}
			}

			return [newMins, newMaxes];
		}

		get data() {
			if (this.buffer.numberOfChannels === 1) {
				return [this.buffer.getChannelData(0), this.buffer.getChannelData(0)];
			} else {
				return [this.buffer.getChannelData(0), this.buffer.getChannelData(1)];
			}
		}

		get length() {
			return this.buffer.length / this.buffer.sampleRate;
		}

		getImage(width, height, startTime, length) {
			var canvas = document.createElement('canvas');
			canvas.width = width;
			canvas.height = height;
			canvas.getContext('2d').fillStyle = 'black';
			this.drawWaveform(canvas, startTime, length);
			return canvas.toDataURL();
		}

		drawWaveform(canvas, startTime, length) {
			var context = canvas.getContext('2d');
			context.clearRect(0, 0, canvas.width, canvas.height);

			if (startTime === undefined) {
				startTime = 0;
			}

			if (length === undefined) {
				length = this.length;
			}

			var pixels = this.summarizeFurther(canvas.width, startTime, length);
			var _startTime = +new Date();
			for (var i = 0; i < canvas.width; i++) {
				context.fillRect(i, -pixels[1][i] * canvas.height / 2 + canvas.height / 2, 1, (pixels[1][i] - pixels[0][i]) * canvas.height / 2);
			}
		}
	}

	/*
		test:
		with maxResolution = 1000
		summarizeFurther(100, 1, 0.1) -> ret
			ret[0] === waveform.summaryMins.slice(1000, 1100)
			ret[1] === waveform.summaryMaxes.slice(1000, 1100)
	*/
</script>
