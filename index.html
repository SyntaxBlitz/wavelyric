<body>
	<canvas id="waveCanvas" width="800" height="200">
	</canvas>	
</body>

<script>
	var audioCtx = new (window.AudioContext || window.webkitAudioContext)();
	var waveform;

	var dropZone = document.body;
	dropZone.ondragover = function (e) {
		e.stopPropagation();
		e.preventDefault();
		
		e.dataTransfer.dropEffect = 'copy';
	};

	dropZone.ondragenter = function (e) {
		document.body.style.backgroundColor='#dfd';
	};

	dropZone.ondragleave = function (e) {
		document.body.style.backgroundColor='white';
	};

	dropZone.ondrop = function (e) {
		e.stopPropagation();
		e.preventDefault();

		document.body.style.backgroundColor='white';

		var files = e.dataTransfer.files;
		if (files.length > 0) {
			var file = files[0];
			
			if (!(file.type.length > 6 && file.type.substring(0, 6) === 'audio/')) {
				return;
			}

			var reader = new FileReader();
			reader.onload = function (e) {
				audioCtx.decodeAudioData(e.target.result).then(function (audioBuffer) {
					editor = new MarkerEditor(document.getElementById('waveCanvas'), audioBuffer);

					editor.markers.push({
						text: "This was a triumph",
						position: 0.21498357095900328
					});
					editor.markers.push({
						text: "I'm making a note here: huge success",
						position: 3.971087351612989
					});
					editor.markers.push({
						text: "It's hard to overstate my satisfaction",
						position: 9.013792006435741
					});
					editor.markers.push({
						text: "Aperture Science",
						position: 16.205408251314033
					});

					document.onkeydown = e => {
						if (e.keyCode === 32) {
							if (editor.playing) {
								editor.stop();
							} else {
								editor.play();
							}
						}
					};
				});
			};

			reader.readAsArrayBuffer(file);
		}
	};

	class MarkerEditor {
		constructor (canvas, audioBuffer) {
			this.waveform = new Waveform(audioBuffer, 1000);

			this.canvas = canvas;
			this.textHeight = 18;
			this.lowerPadding = 50;
			this.textPadding = 5;
			this.markerSlack = 5;
			this.minimumMarkerDistance = 0.05;	// seconds
			this.drawingBounds = {
				x: 0,
				y: 0,
				width: canvas.width,
				height: canvas.height - this.textHeight - this.lowerPadding,
			};
			this.audioBuffer = audioBuffer;
			this.colours = {
				waveformColour: 'black',
				cursorColour: 'rgba(0, 128, 0, 1)',
				defaultMarkerColour: 'rgba(0, 0, 255, 1)',
				passedMarkerColour: 'rgba(0, 0, 255, .33)',
				hoveringMarkerColour: 'rgba(200, 200, 0, 1)'
			};

			this.totalOffset = 0;
			this.startOffset = this.totalOffset;
			this.zoomLevel = this.drawingBounds.width / this.waveform.length;	// pixels per second
			this.mouseStart = 0;
			this.panning = false;
			this.cursor = 0;
			this.playing = false;
			this.listeners = {};
			this.scroll = 0;

			this.markers = [];
			this.lastHoveringMarkerIndex = null;
			this.currentlyDraggingIndex = null;
			this.onShiftClickMarker = null;
			this.dragDeltaSeconds = 0;

			this.lastFrame = 0;
			this.scrollRate = 1;

			this.canvas.focus();

			this.addEventListeners();

			window.requestAnimationFrame(this.canvasRender.bind(this));
		}

		addEventListeners () {
			this.listeners.wheel = e => {
				this.panning = false;

				if (e.deltaY < 0) {		// scroll up
					this.zoom(1.1);
				} else {
					this.zoom(1 / 1.1);
				}
			};
			this.listeners.mousedown = e => {
				this.mouseXFromCanvas = e.clientX - this.canvas.getBoundingClientRect().left;
				this.mouseYFromCanvas = e.clientY - this.canvas.getBoundingClientRect().top;
				this.mouseStart = e.clientX;

				let hoveringMarkerIndex = this.markerHover(this.mouseXFromCanvas, this.mouseYFromCanvas);
				if (hoveringMarkerIndex === null) {
					this.panning = true;
					this.startOffset = this.totalOffset;
				} else if (e.shiftKey && this.onShiftClickMarker) {
					this.onShiftClickMarker(hoveringMarkerIndex);
				} else {
					let mousePositionSeconds = this.mouseXFromCanvas / this.zoomLevel + this.totalOffset;
					this.dragDeltaSeconds = mousePositionSeconds - this.markers[hoveringMarkerIndex].position;
					this.currentlyDraggingIndex = hoveringMarkerIndex;
				}
			};
			this.listeners.mousemove = e => {
				this.mouseXFromCanvas = e.clientX - this.canvas.getBoundingClientRect().left;
				this.mouseYFromCanvas = e.clientY - this.canvas.getBoundingClientRect().top;

				if (this.panning) {
					var mouseNow = e.clientX;
					this.totalOffset = this.startOffset + (this.mouseStart - mouseNow) / this.zoomLevel;
					this.clipOffset();
				}
			};
			this.listeners.mouseup = e => {
				this.panning = false;
				if (e.clientX === this.mouseStart && !this.playing) {	// the mouse was clicked, not dragged
					if (this.currentlyDraggingIndex !== null) {
						this.cursor = this.markers[this.currentlyDraggingIndex].position;	// move the cursor to the clicked marker
					} else {
						var mouseXFromWaveform = this.mouseXFromCanvas - this.drawingBounds.x;
						this.cursor = this.totalOffset + mouseXFromWaveform / this.zoomLevel;
					}
				}
				if (this.currentlyDraggingIndex !== null) {
					this.currentlyDraggingIndex = null;
				}
			};

			this.canvas.addEventListener('wheel', this.listeners.wheel);
			this.canvas.addEventListener('mousedown', this.listeners.mousedown);
			window.addEventListener('mousemove', this.listeners.mousemove);
			window.addEventListener('mouseup', this.listeners.mouseup);
		}

		removeEventListeners() {
			this.canvas.removeEventListener('wheel', this.listeners.wheel);
			this.canvas.removeEventListener('mousedown', this.listeners.mousedown);
			window.removeEventListener('mousemove', this.listeners.mousemove);
			window.removeEventListener('mouseup', this.listeners.mouseup);
		}

		zoom (multiplier) {
			var focus = this.cursor;	// centre zoom on playing cursor

			var zoomLevelMultiplier = multiplier;
			var zoomLevelOriginal = this.zoomLevel;

			this.zoomLevel *= zoomLevelMultiplier;

			if (this.zoomLevel > this.waveform.maxResolution) {
				this.zoomLevel = this.waveform.maxResolution;
			}
			if (this.zoomLevel < this.drawingBounds.width / this.waveform.length) {
				this.zoomLevel = this.drawingBounds.width / this.waveform.length;
			}

			zoomLevelMultiplier = this.zoomLevel / zoomLevelOriginal;	// adjust in case the zoom level was clipped
			this.totalOffset = (this.totalOffset - focus) / zoomLevelMultiplier + focus;	// move the offset so we zoom centred on the cursor

			this.clipOffset();
		}

		canvasRender () {
			this.currentDelta = performance.now() - this.lastFrame;
			this.lastFrame = performance.now();

			if (this.playing) {
				this.cursor = audioCtx.currentTime - this.startTime + this.startTimecode;
				this.centreCursor();
			}

			this.moveDraggable();
			this.doScroll();
			
			this.drawWaveform();
			this.drawMarkers();
			this.drawCursor();

			window.requestAnimationFrame(this.canvasRender.bind(this));
		}

		moveDraggable() {
			if (this.currentlyDraggingIndex !== null) {
				let currentDrag = this.markers[this.currentlyDraggingIndex];

				let lowestAllowed = this.currentlyDraggingIndex * this.minimumMarkerDistance;
				let highestAllowed = this.waveform.length - ((this.markers.length - 1) - this.currentlyDraggingIndex) * this.minimumMarkerDistance;

				currentDrag.position = this.mouseXFromCanvas / this.zoomLevel + this.totalOffset - this.dragDeltaSeconds;
				if (currentDrag.position < lowestAllowed)
					currentDrag.position = lowestAllowed;
				if (currentDrag.position > highestAllowed)
					currentDrag.position = highestAllowed;

				let lesserIterator = this.currentlyDraggingIndex - 1;
				while (lesserIterator >= 0 && this.markers[lesserIterator].position > this.markers[lesserIterator + 1].position - this.minimumMarkerDistance) {
					this.markers[lesserIterator].position = this.markers[lesserIterator + 1].position - this.minimumMarkerDistance;
					lesserIterator--;
				}

				let greaterIterator = this.currentlyDraggingIndex + 1;
				while (greaterIterator < this.markers.length && this.markers[greaterIterator].position < this.markers[greaterIterator - 1].position + this.minimumMarkerDistance) {
					this.markers[greaterIterator].position = this.markers[greaterIterator - 1].position + this.minimumMarkerDistance;
					greaterIterator++;
				}

				if (currentDrag.position < this.totalOffset) {
					this.scroll = -1;
				} else if (currentDrag.position > this.totalOffset + (this.drawingBounds.width / this.zoomLevel)) {
					this.scroll = 1;
				} else {
					this.scroll = 0;
				}
			}
		}

		doScroll () {
			if (this.scroll !== 0) {
				this.totalOffset += this.scroll * this.scrollRate * this.currentDelta / this.zoomLevel;
				this.clipOffset();
			}
		}

		drawWaveform () {
			this.canvas.getContext('2d').fillStyle = this.colours.waveformColour;
			this.waveform.drawWaveform(this.canvas, this.totalOffset, this.drawingBounds.width / this.zoomLevel, this.drawingBounds.x, this.drawingBounds.y, this.drawingBounds.width, this.drawingBounds.height);
		}

		drawMarkers() {
			// this method does make some assumptions about the drawing bounds:
			// 	the waveform takes up the entire horizontal span of the canvas
			//	the waveform is at the top of the canvas
			// 	this.drawingBounds.height + this.textHeight + this.lowerPadding == this.canvas.height

			var context = this.canvas.getContext('2d');

			let currentHoveringMarkerIndex = this.markerHover(this.mouseXFromCanvas, this.mouseYFromCanvas);
			if (this.lastHoveringMarkerIndex !== null) {
				this.markers[this.lastHoveringMarkerIndex].hovering = false;
			}
			this.lastHoveringMarkerIndex = currentHoveringMarkerIndex;
			if (currentHoveringMarkerIndex !== null) {
				document.body.style.cursor = 'pointer';
				this.markers[currentHoveringMarkerIndex].hovering = true;
			} else {
				document.body.style.cursor = 'auto';
			}

			context.clearRect(0, this.drawingBounds.height, this.canvas.width, this.textHeight + this.lowerPadding);

			for (var i = 0; i < this.markers.length; i++) {
				let marker = this.markers[i];

				if (marker.hovering)
					context.fillStyle = this.colours.hoveringMarkerColour;
				else if (marker.position > this.cursor)
					context.fillStyle = this.colours.defaultMarkerColour;
				else
					context.fillStyle = this.colours.passedMarkerColour;

				var markerX = (marker.position - this.totalOffset) * this.zoomLevel;
				if (Math.abs(marker.position - this.waveform.length) < 1e-6) {	// if they're equal (floats)
					markerX -= 1;
				}
				context.fillRect(markerX, 0, 1, this.drawingBounds.height + this.textHeight);

				context.font = this.textHeight + 'px sans-serif';
				if (i === this.markers.length - 1) {
					context.fillText(marker.text, markerX + this.textPadding, this.drawingBounds.height + this.textHeight);
				} else {
					var maxTextWidth = (this.markers[i + 1].position - marker.position) * this.zoomLevel - this.textPadding * 2;

					let text = marker.text;
					let chars = marker.text.length;
					while (context.measureText(text).width > maxTextWidth) {
						chars--;
						if (chars <= 0) {
							text = '';
							break;
						}
						text = marker.text.substring(0, chars) + '...';
					}
					context.fillText(text, markerX + this.textPadding, this.drawingBounds.height + this.textHeight);
				}
			}
		}

		markerHover (mouseX, mouseY) {
			if (mouseX > this.drawingBounds.width)
				return null;

			// assert this.markers is sorted by ascending position
			var mouseSeconds = mouseX / this.zoomLevel + this.totalOffset;
			var closestDistance = this.waveform.length;
			var closestDistanceIndex = this.markers.length - 1;

			var chosenMarkerIndex = null;
			for (let i = 0; i < this.markers.length; i++) {
				let markerDistance = Math.abs(this.markers[i].position - mouseSeconds);
				if (markerDistance < closestDistance) {
					closestDistance = markerDistance;
				} else {
					closestDistanceIndex = i - 1;
					break;
				}
			}

			if (closestDistance * this.zoomLevel < this.markerSlack) {
				chosenMarkerIndex = closestDistanceIndex;
			}

			if (chosenMarkerIndex === null && mouseY > this.drawingBounds.height && mouseY <= this.drawingBounds.height + this.textHeight) {
				let lastMarkerToLeftIndex = this.markers.length - 1;
				for (let i = 0; i < this.markers.length; i++) {
					if (this.markers[i].position < mouseSeconds) {
						lastMarkerToLeftIndex = i;
					} else {
						break;
					}
				}

				let context = this.canvas.getContext('2d');
				context.font = this.textHeight + 'px sans-serif';
				let textWidth = context.measureText(this.markers[lastMarkerToLeftIndex].text).width;
				if (mouseX < (this.markers[lastMarkerToLeftIndex].position - this.totalOffset) * this.zoomLevel + this.textPadding + textWidth) {
					chosenMarkerIndex = lastMarkerToLeftIndex;
				}
			}

			return chosenMarkerIndex;
		}

		drawCursor () {
			var cursorX = (this.cursor - this.totalOffset) * this.zoomLevel + this.drawingBounds.x;
			if (cursorX >= this.drawingBounds.x && cursorX <= this.drawingBounds.x + this.drawingBounds.width) {
				this.canvas.getContext('2d').fillStyle = this.colours.cursorColour;
				this.canvas.getContext('2d').fillRect(cursorX, this.drawingBounds.y, 1, this.drawingBounds.height);
			}
		}

		clipOffset () {
			if (this.totalOffset < 0)
				this.totalOffset = 0;
			if (this.drawingBounds.width > (this.waveform.length - this.totalOffset) * this.zoomLevel)
				this.totalOffset = this.waveform.length - this.drawingBounds.width / this.zoomLevel;
		};

		centreCursor () {
			var secondsOnScreen = this.drawingBounds.width / this.zoomLevel;
			this.totalOffset = this.cursor - secondsOnScreen / 2;
			this.clipOffset();
		};

		play () {
			if (this.playing)
				return;

			this.playing = true;

			this.source = audioCtx.createBufferSource();
			this.source.buffer = this.audioBuffer;
			this.source.connect(audioCtx.destination);
			this.source.start(0, this.cursor);

			this.startTime = audioCtx.currentTime;
			this.startTimecode = this.cursor;
		}

		stop () {
			if (!this.playing)
				return;

			this.playing = false;

			this.source.stop();
		}
	}

	class Waveform {
		constructor (arrayBuffer, maxResolution) {
			this.buffer = arrayBuffer;
			this.maxResolution = maxResolution;
			this.summarize(maxResolution);
			
			console.log('waveform constructed');
		}

		summarize (pixelsPerSecond) {
			var data = this.data;
			var scaleFactor = Math.floor(data[0].length / (pixelsPerSecond * this.length));

			this.summaryMins = new Float32Array(Math.ceil(data[0].length / scaleFactor));
			this.summaryMaxes = new Float32Array(Math.ceil(data[0].length / scaleFactor));

			for (var i = 0; i < this.summaryMins.length; i++) {
				var currentMin = 1;
				var currentMax = -1;

				for (var j = 0; j < scaleFactor; j++) {
					var n = i * scaleFactor + j;
					if (n < data[0].length) {
						var sample = (data[0][n] + data[1][n]) / 2;
						if (sample < currentMin)
							currentMin = sample;
						if (sample > currentMax)
							currentMax = sample;
					} else {
						break;
					}
				}

				if (currentMin < -1)	// this happens!
					currentMin = -1;
				if (currentMax > 1)
					currentMax = 1;

				this.summaryMins[i] = currentMin;
				this.summaryMaxes[i] = currentMax;
			}
		}

		summarizeFurther (pixels, startTime, length) {
			if (!this.summaryMins || !this.summaryMaxes)
				return;

			var newMins = new Float32Array(pixels);
			var newMaxes = new Float32Array(pixels);

			var summaryOffset = Math.floor(startTime * this.maxResolution);
			var lengthFrames = Math.floor(length * this.maxResolution);

			if (lengthFrames < pixels) {	// The old summary's length over this time region is smaller; we're expanding
				var currentPixel = 0;
				for (var i = 0; i < lengthFrames; i++) {
					while (currentPixel / pixels < (i + 1) / lengthFrames) {	// we use i + 1 so it takes a whole batch from the start
						newMins[currentPixel] = this.summaryMins[summaryOffset + i];
						newMaxes[currentPixel] = this.summaryMaxes[summaryOffset + i];
						currentPixel++;
					}
				}
			} else {	// We're condensing old summary data down into a smaller space (this should happen more often)
				var framesPerVirtualPixel = lengthFrames / pixels;
				var totalSummaryFrames = this.length * this.maxResolution;
				var virtualPixelsPerFrame = 1 / framesPerVirtualPixel;
				var totalVirtualPixels = totalSummaryFrames * virtualPixelsPerFrame;
				var initialVirtualPixel = Math.floor(startTime / this.length * totalVirtualPixels);

				var i = 0;
				for (var virtualPixel = initialVirtualPixel; virtualPixel < initialVirtualPixel + pixels; virtualPixel++) {

					// at certain bitrates there is occasionally a problem with vertical lines showing up at close zooms.
					// this is because there's not always a frame available to a virtual pixel.
					// in these cases, we copy the previous pixel.
					if (Math.floor(virtualPixel / totalVirtualPixels * totalSummaryFrames) !== Math.floor((virtualPixel + 1) / totalVirtualPixels * totalSummaryFrames)) {
						var currentMin = 1;
						var currentMax = -1;

						for (var frame = Math.floor(virtualPixel / totalVirtualPixels * totalSummaryFrames); frame < Math.floor((virtualPixel + 1) / totalVirtualPixels * totalSummaryFrames); frame++) {
							if (this.summaryMins[frame] < currentMin)
								currentMin = this.summaryMins[frame];
							if (this.summaryMaxes[frame] > currentMax)
								currentMax = this.summaryMaxes[frame];
						}

						newMins[i] = currentMin;
						newMaxes[i] = currentMax;
					} else if (i !== 0) {
						newMins[i] = newMins[i - 1];
						newMaxes[i] = newMaxes[i - 1];
					} else {
						newMins[i] = 0;
						newMaxes[i] = 0;
					}

					i++;
				}
			}

			return [newMins, newMaxes];
		}

		get data() {
			if (this.buffer.numberOfChannels === 1) {
				return [this.buffer.getChannelData(0), this.buffer.getChannelData(0)];
			} else {
				return [this.buffer.getChannelData(0), this.buffer.getChannelData(1)];
			}
		}

		get length() {
			return this.buffer.length / this.buffer.sampleRate;
		}

		getImage(width, height, startTime, length) {
			var canvas = document.createElement('canvas');
			canvas.width = width;
			canvas.height = height;
			canvas.getContext('2d').fillStyle = 'black';
			this.drawWaveform(canvas, startTime, length);
			return canvas.toDataURL();
		}

		drawWaveform(canvas, startTime, length, x, y, width, height) {
			if (x === undefined)
				x = 0;
			if (y === undefined)
				y = 0;
			if (width === undefined)
				width = canvas.width;
			if (height === undefined)
				height = canvas.height;

			var context = canvas.getContext('2d');
			context.clearRect(x, y, width, height);

			if (startTime === undefined) {
				startTime = 0;
			}

			if (length === undefined) {
				length = this.length;
			}

			var pixels = this.summarizeFurther(width, startTime, length);
			
			for (var i = x; i < x + width; i++) {
				context.fillRect(i, y + -pixels[1][i] * height / 2 + height / 2, 1, (pixels[1][i] - pixels[0][i]) * height / 2);
			}
		}
	}

	/*
		test:
		with maxResolution = 1000
		summarizeFurther(100, 1, 0.1) -> ret
			ret[0] === waveform.summaryMins.slice(1000, 1100)
			ret[1] === waveform.summaryMaxes.slice(1000, 1100)
	*/
</script>
